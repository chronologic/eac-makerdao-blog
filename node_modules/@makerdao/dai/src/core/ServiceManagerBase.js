'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _StateMachine = require('./StateMachine');

var _StateMachine2 = _interopRequireDefault(_StateMachine);

var _ServiceState = require('./ServiceState');

var _ServiceState2 = _interopRequireDefault(_ServiceState);

var _ServiceType = require('./ServiceType');

var _ServiceType2 = _interopRequireDefault(_ServiceType);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('dai:ServiceManagerBase');

function _promisify(unsafeCallback) {
  return new _promise2.default(function (resolve, reject) {
    try {
      resolve(unsafeCallback());
    } catch (e) {
      reject(e.message);
    }
  });
}

var ServiceManagerBase = function () {
  /**
   * @param init {function|null}
   * @param connect {function|null}
   * @param auth {function|null}
   */
  function ServiceManagerBase() {
    var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var connect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var auth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    (0, _classCallCheck3.default)(this, ServiceManagerBase);

    // Validate init
    if (init !== null && typeof init !== 'function') {
      throw new Error('Invalid argument init: not a function or null.');
    } else if (init === null) {
      init = function init() {
        return _promise2.default.resolve();
      };
    }

    // Validate connect
    if (connect !== null && typeof connect !== 'function') {
      throw new Error('Invalid argument connect: not a function or null.');
    } else if (connect === null && auth !== null) {
      connect = function connect() {
        return _promise2.default.resolve();
      };
    }

    // Validate auth
    if (auth !== null && typeof auth !== 'function') {
      throw new Error('Invalid argument auth: not a function or null.');
    }

    // Set initial props
    this._init = init;
    this._connect = connect;
    this._auth = auth;
    this._type = auth === null ? connect === null ? _ServiceType2.default.LOCAL : _ServiceType2.default.PUBLIC : _ServiceType2.default.PRIVATE;
    this._state = new _StateMachine2.default(_ServiceState2.default.CREATED, _ServiceType.serviceTypeTransitions[this._type]);
    this._initPromise = null;
    this._connectPromise = null;
    this._authPromise = null;
  }

  /**
   * @returns {Promise}
   */


  (0, _createClass3.default)(ServiceManagerBase, [{
    key: 'initialize',
    value: function initialize(settings) {
      var _this = this;

      // If our current state is preceding the INITIALIZING state, we need to set up initialization
      if (this._state.inState(_ServiceState2.default.CREATED)) {
        // Assert that there is no initPromise at this point
        /* istanbul ignore next */
        if (this._initPromise) {
          throw new Error('Unexpected init promise in state CREATED.');
        }

        // Enter the INITIALIZING state
        this._state.transitionTo(_ServiceState2.default.INITIALIZING);

        // After trying to initialize, transition to the success state (READY/OFFLINE) or revert to CREATED
        this._initPromise = _promisify(function () {
          return _this._init(settings);
        }).then(function () {
          return _this._state.transitionTo(_this._type === _ServiceType2.default.LOCAL ? _ServiceState2.default.READY : _ServiceState2.default.OFFLINE);
        }, function (reason) {
          log(reason);
          _this._state.transitionTo(_ServiceState2.default.CREATED);
          throw reason;
        });
      }

      return this._initPromise;
    }

    /**
     * @returns {Promise}
     */

  }, {
    key: 'connect',
    value: function connect() {
      var _this2 = this;

      // Local Services are 'connected' whenever they are initialized
      if (this._type === _ServiceType2.default.LOCAL) {
        return this.initialize();
      }

      // If our current state is preceding the CONNECTING state, we need to set up a new connection
      if (this._state.inState([_ServiceState2.default.CREATED, _ServiceState2.default.INITIALIZING, _ServiceState2.default.OFFLINE]) && this._connectPromise === null) {
        // Make sure to be initialized before trying to connect
        this._connectPromise = this.initialize().then(function () {
          // Enter the CONNECTING state
          _this2._state.transitionTo(_ServiceState2.default.CONNECTING);

          // After trying to connect, transition to the success state (ONLINE/READY) or revert to OFFLINE.
          return _promisify(function () {
            return _this2._connect(function () {
              return _this2._disconnect();
            });
          }).then(function () {
            // Check if we are still CONNECTING, because another process might have come in between
            if (_this2._state.inState(_ServiceState2.default.CONNECTING)) {
              _this2._state.transitionTo(_this2._type === _ServiceType2.default.PUBLIC ? _ServiceState2.default.READY : _ServiceState2.default.ONLINE);
            }
          }, function (error) {
            log('connect error:', error);
            // Check if we are still CONNECTING, because another process might have come in between
            if (_this2._state.inState(_ServiceState2.default.CONNECTING)) {
              _this2._state.transitionTo(_ServiceState2.default.OFFLINE);
            }
            throw error;
          });
        });
      }

      return this._connectPromise;
    }

    /**
     * @returns {Promise}
     */

  }, {
    key: 'authenticate',
    value: function authenticate() {
      var _this3 = this;

      // Public and Local Services are 'authenticated' whenever they are connected (/initialized)
      if (this._type !== _ServiceType2.default.PRIVATE) {
        return this.connect();
      }

      // If our current state is preceding the AUTHENTICATING state, we need to set up a new authentication
      if (this._state.inState([_ServiceState2.default.CREATED, _ServiceState2.default.INITIALIZING, _ServiceState2.default.OFFLINE, _ServiceState2.default.CONNECTING, _ServiceState2.default.ONLINE]) && this._authPromise === null) {
        // Make sure to be connected before trying to authenticate
        this._authPromise = this.connect().then(function () {
          // Enter the AUTHENTICATING state
          _this3._state.transitionTo(_ServiceState2.default.AUTHENTICATING);

          // After trying to authenticate, transition to the success state (READY) or revert to ONLINE
          return _promisify(function () {
            return _this3._auth(function () {
              return _this3._deauthenticate();
            });
          }).then(function () {
            // Check if we are still AUTHENTICATING, because another process might have come in between
            // (Most notably, a disconnect may have transitioned us into OFFLINE state).
            if (_this3._state.inState(_ServiceState2.default.AUTHENTICATING)) {
              _this3._state.transitionTo(_ServiceState2.default.READY);
            }
          }, function (reason) {
            log('authenticate error: ' + reason);
            // Check if we are still AUTHENTICATING, because another process might have come in between
            if (_this3._state.inState(_ServiceState2.default.AUTHENTICATING)) {
              _this3._state.transitionTo(_ServiceState2.default.ONLINE);
            }
          });
        });
      }

      return this._authPromise;
    }

    /**
     * @returns { ServiceManagerBase }
     */

  }, {
    key: 'settings',
    value: function settings(_settings) {
      this._settings = _settings;
      return this;
    }

    /**
     * @returns {string}
     */

  }, {
    key: 'state',
    value: function state() {
      return this._state.state();
    }

    /**
     * @returns {string}
     */

  }, {
    key: 'type',
    value: function type() {
      return this._type;
    }

    /**
     * @returns {boolean}
     */

  }, {
    key: 'isInitialized',
    value: function isInitialized() {
      return !this._state.inState([_ServiceState2.default.CREATED, _ServiceState2.default.INITIALIZING]);
    }

    /**
     * @returns {boolean|null}
     */

  }, {
    key: 'isConnected',
    value: function isConnected() {
      return this._type === _ServiceType2.default.LOCAL ? null : this._state.inState([_ServiceState2.default.ONLINE, _ServiceState2.default.AUTHENTICATING, _ServiceState2.default.READY]);
    }

    /**
     * @returns {boolean|null}
     */

  }, {
    key: 'isAuthenticated',
    value: function isAuthenticated() {
      return this._type === _ServiceType2.default.PRIVATE ? this._state.inState(_ServiceState2.default.READY) : null;
    }

    /**
     * @returns {boolean}
     */

  }, {
    key: 'isReady',
    value: function isReady() {
      return this._state.inState(_ServiceState2.default.READY);
    }

    /**
     * @param {function} handler
     * @returns {ServiceManagerBase}
     */

  }, {
    key: 'onInitialized',
    value: function onInitialized(handler) {
      this._state.onStateChanged(function (oldState, newState) {
        if (oldState === _ServiceState2.default.INITIALIZING && (newState === _ServiceState2.default.OFFLINE || newState === _ServiceState2.default.READY)) {
          handler();
        }
      });

      return this;
    }

    /**
     * @param {function} handler
     * @returns {ServiceManagerBase}
     */

  }, {
    key: 'onConnected',
    value: function onConnected(handler) {
      this._state.onStateChanged(function (oldState, newState) {
        if (oldState === _ServiceState2.default.CONNECTING && (newState === _ServiceState2.default.ONLINE || newState === _ServiceState2.default.READY)) {
          handler();
        }
      });

      return this;
    }

    /**
     * @param {function} handler
     * @returns {ServiceManagerBase}
     */

  }, {
    key: 'onDisconnected',
    value: function onDisconnected(handler) {
      this._state.onStateChanged(function (oldState, newState) {
        if (newState === _ServiceState2.default.OFFLINE && (oldState === _ServiceState2.default.ONLINE || oldState === _ServiceState2.default.READY)) {
          handler();
        }
      });

      return this;
    }

    /**
     * @param {function} handler
     * @returns {ServiceManagerBase}
     */

  }, {
    key: 'onAuthenticated',
    value: function onAuthenticated(handler) {
      this._state.onStateChanged(function (oldState, newState) {
        if (oldState === _ServiceState2.default.AUTHENTICATING && newState === _ServiceState2.default.READY) {
          handler();
        }
      });

      return this;
    }

    /**
     * @param {function} handler
     * @returns {ServiceManagerBase}
     */

  }, {
    key: 'onDeauthenticated',
    value: function onDeauthenticated(handler) {
      if (this.type() === _ServiceType2.default.PRIVATE) {
        this._state.onStateChanged(function (oldState, newState) {
          if ((newState === _ServiceState2.default.OFFLINE || newState === _ServiceState2.default.ONLINE) && oldState === _ServiceState2.default.READY) {
            handler();
          }
        });
      }

      return this;
    }

    /**
     * @param {function} handler
     * @returns {ServiceManagerBase}
     */

  }, {
    key: 'onReady',
    value: function onReady(handler) {
      this._state.onStateChanged(function (_, newState) {
        if (newState === _ServiceState2.default.READY) {
          handler();
        }
      });

      return this;
    }

    /**
     * @param {function} handler
     * @returns {ServiceManagerBase}
     */

  }, {
    key: 'onStateChanged',
    value: function onStateChanged(handler) {
      this._state.onStateChanged(handler);
      return this;
    }

    /**
     * This is called by the service implementation object, which is the only authority with knowledge on the true
     * connection status. This will e.g. get called when a ping signal is no longer returned by the back-end and the
     * service implementation object concludes that we are therefore offline.
     *
     * @private
     */

  }, {
    key: '_disconnect',
    value: function _disconnect() {
      /* istanbul ignore next */
      if (this._type === _ServiceType2.default.LOCAL) {
        throw new Error('_disconnect must not be called on a Local Service');
      }

      if (this._state.inState(_ServiceState2.default.AUTHENTICATING)) {
        this._deauthenticate();
      }

      if (this._state.inState([_ServiceState2.default.READY, _ServiceState2.default.ONLINE, _ServiceState2.default.CONNECTING])) {
        this._authPromise = null;
        this._connectPromise = null;

        this._state.transitionTo(_ServiceState2.default.OFFLINE);
      }
    }

    /**
     * This is called by the service implementation object, which is the only authority with knowledge on the true
     * authentication status. This will e.g. get called when an authentication token expires or a user logs out, and the
     * service implementation object concludes that we are therefore no longer authenticated.
     *
     * @private
     */

  }, {
    key: '_deauthenticate',
    value: function _deauthenticate() {
      /* istanbul ignore next */
      if (this._type !== _ServiceType2.default.PRIVATE) {
        throw new Error('_deauthenticate must not be called on a Local or Public Service');
      }

      if (this._state.inState([_ServiceState2.default.READY, _ServiceState2.default.AUTHENTICATING])) {
        this._authPromise = null;
        this._state.transitionTo(_ServiceState2.default.ONLINE);
      }
    }
  }]);
  return ServiceManagerBase;
}();

exports.default = ServiceManagerBase;
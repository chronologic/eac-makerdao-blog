'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash.uniq');

var _lodash2 = _interopRequireDefault(_lodash);

var _Container = require('../core/Container');

var _Container2 = _interopRequireDefault(_Container);

var _index = require('./index');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ServiceProvider = function () {
  function ServiceProvider(config, _ref) {
    var services = _ref.services,
        defaults = _ref.defaults,
        disabled = _ref.disabled;
    (0, _classCallCheck3.default)(this, ServiceProvider);

    this._config = config;

    // all the service classes that this provider should support
    this._services = services;

    // the services (as string names) that should be used for each role by
    // default, or when that role is disabled
    this._resolver = { defaults: defaults, disabled: disabled };
  }

  /**
   * @param {string} serviceName
   * @returns {boolean}
   */


  (0, _createClass3.default)(ServiceProvider, [{
    key: 'supports',
    value: function supports(serviceName) {
      return !!this._services[serviceName];
    }

    /**
     * @param {object} servicesConfig
     * @returns {Container}
     */

  }, {
    key: 'buildContainer',
    value: function buildContainer() {
      var container = new _Container2.default();

      for (var role in this._config) {
        var _standardizeConfig = (0, _index.standardizeConfig)(role, this._config[role], this._resolver),
            _standardizeConfig2 = (0, _slicedToArray3.default)(_standardizeConfig, 2),
            service = _standardizeConfig2[0],
            settings = _standardizeConfig2[1];

        var instance = void 0;

        // each config can contain a service descriptor in one of several forms:
        if ((typeof service === 'undefined' ? 'undefined' : (0, _typeof3.default)(service)) == 'object') {
          // instance
          instance = service;
        } else if (typeof service == 'function') {
          // constructor
          instance = new service();
        } else {
          // string
          if (!this.supports(service)) {
            throw new Error('Unsupported service in configuration: ' + service);
          }

          instance = new this._services[service]();
        }

        instance.manager().settings(settings);
        container.register(instance, role);
      }

      this._registerDependencies(container);
      container.injectDependencies();
      this._container = container;
      return container;
    }
  }, {
    key: '_registerDependencies',
    value: function _registerDependencies(container) {
      var names = container.getRegisteredServiceNames();

      // get the names of all dependencies
      var allDeps = names.reduce(function (acc, name) {
        var service = container.service(name);
        var deps = service.manager().dependencies();
        return (0, _lodash2.default)(acc.concat(deps));
      }, []);

      // filter out the ones that are already registered
      var newDeps = allDeps.filter(function (name) {
        return !names.includes(name);
      });
      if (newDeps.length === 0) return;

      // register any remaining ones
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(newDeps), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var name = _step.value;

          var className = this._resolver.defaults[name];
          var ctor = this._services[className];
          if (!ctor) throw new Error('No service found for "' + name + '"');
          container.register(new ctor(), name);
        }

        // repeat, to find any dependencies for services that were just added
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._registerDependencies(container);
    }
  }, {
    key: 'service',
    value: function service(name) {
      if (!this._container) this.buildContainer();
      return this._container.service(name);
    }
  }]);
  return ServiceProvider;
}();

exports.default = ServiceProvider;
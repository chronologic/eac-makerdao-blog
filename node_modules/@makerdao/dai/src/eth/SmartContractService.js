'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _PublicService2 = require('../core/PublicService');

var _PublicService3 = _interopRequireDefault(_PublicService2);

var _contracts = require('../../contracts/contracts');

var _contracts2 = _interopRequireDefault(_contracts);

var _tokens = require('../../contracts/tokens');

var _tokens2 = _interopRequireDefault(_tokens);

var _networks = require('../../contracts/networks');

var _networks2 = _interopRequireDefault(_networks);

var _ethers = require('ethers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function wrapContract(contract, name, abi, txManager) {
  var nonConstantFns = {};

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(abi), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ref = _step.value;
      var type = _ref.type,
          constant = _ref.constant,
          _name = _ref.name;

      if (type === 'function' && !constant) nonConstantFns[_name] = true;
    }

    // The functions in ethers.Contract are set up as read-only, non-configurable
    // properties, which means if we try to change their values with Proxy, we
    // get an error. See https://stackoverflow.com/a/48495509/56817 for more
    // detail.
    //
    // But that only happens if the contract is specified as the first argument
    // to Proxy. So we don't do that. Go on, wag your finger.
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var proxy = new Proxy({}, {
    get: function get(target, key) {
      if (nonConstantFns[key] && txManager) {
        return function () {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return txManager.formatHybridTx(contract, key, args, name);
        };
      }

      return contract[key];
    },
    set: function set(target, key, value) {
      contract[key] = value;
      return true;
    }
  });

  return proxy;
}

var SmartContractService = function (_PublicService) {
  (0, _inherits3.default)(SmartContractService, _PublicService);

  function SmartContractService() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'smartContract';
    (0, _classCallCheck3.default)(this, SmartContractService);
    return (0, _possibleConstructorReturn3.default)(this, (SmartContractService.__proto__ || (0, _getPrototypeOf2.default)(SmartContractService)).call(this, name, ['web3', 'log', 'transactionManager']));
  }

  (0, _createClass3.default)(SmartContractService, [{
    key: 'initialize',
    value: function initialize() {
      var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (settings.addContracts) {
        this._addedContracts = (0, _keys2.default)(settings.addContracts).reduce(function (acc, key) {
          var def = settings.addContracts[key];
          acc[key] = [(0, _extends3.default)({}, def, { version: 1 })];
          return acc;
        }, {});
      }
    }
  }, {
    key: 'getContractByAddressAndAbi',
    value: function getContractByAddressAndAbi(address, abi) {
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          name = _ref2.name,
          _ref2$hybrid = _ref2.hybrid,
          hybrid = _ref2$hybrid === undefined ? true : _ref2$hybrid;

      if (!address) throw Error('Contract address is required');
      if (!name) name = this.lookupContractName(address);

      // this signer just delegates to the provider
      var signer = this.get('web3').ethersProvider().getSigner();
      var contract = new _ethers.Contract(address, abi, signer);
      var txManager = hybrid ? this.get('transactionManager') : null;
      return wrapContract(contract, name, abi, txManager);
    }
  }, {
    key: 'getContractByName',
    value: function getContractByName(name) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          version = _ref3.version,
          _ref3$hybrid = _ref3.hybrid,
          hybrid = _ref3$hybrid === undefined ? true : _ref3$hybrid;

      var info = this._getContractInfo(name, version);
      return this.getContractByAddressAndAbi(info.address, info.abi, {
        name: name,
        hybrid: hybrid
      });
    }
  }, {
    key: 'lookupContractName',
    value: function lookupContractName(address) {
      address = address.toUpperCase();
      var contracts = this._getAllContractInfo();
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(contracts)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var name = _step2.value;

          var versions = contracts[name];
          if (versions.find(function (info) {
            return info.address.toUpperCase() === address;
          })) {
            return name;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return null;
    }
  }, {
    key: 'getContractState',
    value: function getContractState(name) {
      var recursion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var beautify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var _this2 = this;

      var exclude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ['tag', 'SAI_PEP.read'];
      var visited = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];

      var info = this._getContractInfo(name),
          contract = this.getContractByAddressAndAbi(info.address, info.abi),
          inspectableMembers = info.abi.filter(function (m) {
        return m.constant && m.inputs.length < 1;
      }).map(function (m) {
        var member = m.name;

        if (exclude.indexOf(member) > -1 || exclude.indexOf(name + '.' + member) > -1) {
          return {
            name: member,
            promise: _promise2.default.resolve('[EXCLUDED]')
          };
        }

        return {
          name: member,
          promise: contract[m.name]().catch(function (reason) {
            return '[ERROR: ' + reason + ']';
          })
        };
      });

      visited = visited.concat([name]);

      return _promise2.default.all(inspectableMembers.map(function (m) {
        return m.promise;
      })).then(function (results) {
        var valuePromises = [];

        var _loop = function _loop(i) {
          var key = inspectableMembers[i].name,
              value = results[i],
              contractName = _this2.lookupContractName(value.toString());

          if (contractName && recursion > 0 && visited.indexOf(contractName) < 0) {
            valuePromises.push(_this2.getContractState(contractName, recursion - 1, beautify, exclude, visited).then(function (childState) {
              return [key, childState];
            }));
            visited = visited.concat([contractName]);
          } else if (contractName && visited.indexOf(contractName) > -1) {
            valuePromises.push([key, beautify ? value + '; ' + contractName + '; [VISITED]' : value]);
          } else if (contractName) {
            valuePromises.push([key, beautify ? value + '; ' + contractName : value]);
          } else {
            valuePromises.push([key, beautify ? value.toString() : value]);
          }
        };

        for (var i = 0; i < results.length; i++) {
          _loop(i);
        }

        return _promise2.default.all(valuePromises);
      }).then(function (values) {
        var result = { __self: contract.address + '; ' + name };
        values.forEach(function (v) {
          return result[v[0]] = v.length > 2 ? v.slice(1) : v[1];
        });
        return result;
      });
    }
  }, {
    key: 'hasContract',
    value: function hasContract(name) {
      return (0, _keys2.default)(_contracts2.default).indexOf(name) > -1 || (0, _keys2.default)(_tokens2.default).indexOf(name) > -1 || (0, _keys2.default)(this._addedContracts || {}).indexOf(name) > -1;
    }

    // generally we should be using the ethers contract interface. this is only
    // for edge cases that the ethers contract interface doesn't support, like
    // calling (but not sending) a non-constant function

  }, {
    key: 'getWeb3ContractByName',
    value: function getWeb3ContractByName(name) {
      var _getContractInfo2 = this._getContractInfo(name),
          abi = _getContractInfo2.abi,
          address = _getContractInfo2.address;

      return this.get('web3').web3Contract(abi, address);
    }
  }, {
    key: '_getContractInfo',
    value: function _getContractInfo(name, version) {
      if (!this.hasContract(name)) {
        throw new Error('Provided name "' + name + '" is not a contract');
      }

      var contracts = this._getAllContractInfo();
      var versions = contracts[name];
      if (!version) version = Math.max.apply(Math, (0, _toConsumableArray3.default)(versions.map(function (info) {
        return info.version;
      })));
      var contractInfo = versions.find(function (info) {
        return info.version === version;
      });

      if (!contractInfo) {
        throw new Error('Cannot find contract ' + name + ', version ' + version);
      }

      return contractInfo;
    }
  }, {
    key: '_getAllContractInfo',
    value: function _getAllContractInfo() {
      var id = this.get('web3').networkId(),
          mapping = _networks2.default.find(function (m) {
        return m.networkId === id;
      });

      if (!mapping) throw new Error('Network ID ' + id + ' not found in mapping.');
      var infos = mapping.addresses;
      if (this._addedContracts) {
        var infos2 = (0, _extends3.default)({}, infos, this._addedContracts);
        return infos2;
      }
      return infos;
    }
  }]);
  return SmartContractService;
}(_PublicService3.default);

exports.default = SmartContractService;
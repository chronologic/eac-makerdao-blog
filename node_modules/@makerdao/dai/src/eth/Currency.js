'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.USD_WETH = exports.USD_PETH = exports.USD_MKR = exports.USD_ETH = exports.USD_DAI = exports.USD = exports.WETH = exports.PETH = exports.MKR = exports.ETH = exports.DAI = exports.CurrencyRatio = exports.currencies = exports.Currency = undefined;

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _toArray2 = require('babel-runtime/helpers/toArray');

var _toArray3 = _interopRequireDefault(_toArray2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

exports.getCurrency = getCurrency;

var _tokens = require('../../contracts/tokens');

var _tokens2 = _interopRequireDefault(_tokens);

var _lodash = require('lodash.values');

var _lodash2 = _interopRequireDefault(_lodash);

var _ethers = require('ethers');

var _bignumber = require('bignumber.js');

var _bignumber2 = _interopRequireDefault(_bignumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var bigNumberify = _ethers.utils.bigNumberify;


function amountToBigNumber(amount) {
  if (amount instanceof Currency) return amount.toBigNumber();
  var value = (0, _bignumber2.default)(amount);
  if (value.lt(0)) throw new Error('amount cannot be negative');
  if (value.isNaN()) throw new Error('amount "' + amount + '" is not a number');
  return value;
}

var Currency = exports.Currency = function () {
  function Currency(amount) {
    var shift = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck3.default)(this, Currency);

    if (shift === 'wei') shift = -18;
    if (shift === 'ray') shift = -27;
    this._amount = shift ? amountToBigNumber(amount).shiftedBy(shift) : amountToBigNumber(amount);
    this.symbol = '???';
  }

  (0, _createClass3.default)(Currency, [{
    key: 'isEqual',
    value: function isEqual(other) {
      return this._amount.eq(other._amount) && this.symbol == other.symbol;
    }
  }, {
    key: 'toString',
    value: function toString() {
      var decimals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;

      return this._amount.toFixed(decimals) + ' ' + this.symbol;
    }
  }, {
    key: 'toBigNumber',
    value: function toBigNumber() {
      return this._amount;
    }
  }, {
    key: 'toNumber',
    value: function toNumber() {
      return this._amount.toNumber();
    }
  }, {
    key: 'toEthersBigNumber',
    value: function toEthersBigNumber() {
      var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (shift === 'wei') shift = 18;
      if (shift === 'ray') shift = 27;

      // always round down so that we never attempt to spend more than we have
      var val = this._amount.shiftedBy(shift).integerValue(_bignumber2.default.ROUND_DOWN).toFixed();

      try {
        return bigNumberify(val);
      } catch (err) {
        throw new Error('couldn\'t bigNumberify ' + val);
      }
    }
  }, {
    key: 'isSameType',
    value: function isSameType(other) {
      return this.symbol === other.symbol;
    }
  }]);
  return Currency;
}();

var mathFunctions = [['plus'], ['minus'], ['times', 'multipliedBy'], ['div', 'dividedBy'], ['shiftedBy']];

var booleanFunctions = [['isLessThan', 'lt'], ['isLessThanOrEqualTo', 'lte'], ['isGreaterThan', 'gt'], ['isGreaterThanOrEqualTo', 'gte'], ['eq']];

function assertValidOperation(method, left, right) {
  var message = 'Invalid operation: ' + left.symbol + ' ' + method + ' ' + right.symbol;

  if (!(right instanceof Currency) || left.isSameType(right)) return;

  if (right instanceof CurrencyRatio) {
    // only supporting Currency as a left operand for now, though we could
    // extend this to support ratio-ratio math if needed
    switch (method) {
      case 'times':
        if (left.isSameType(right.denominator)) return;
        break;
      case 'div':
        if (left.isSameType(right.numerator)) return;
        break;
    }
  }

  switch (method) {
    // division between two different units results in a ratio, e.g. USD/DAI
    case 'div':
      return;
  }

  throw new Error(message);
}

function result(method, left, right, value) {
  if (right instanceof CurrencyRatio) {
    switch (method) {
      case 'times':
        return new right.numerator(value);
      case 'div':
        return new right.denominator(value);
    }
  }

  if (!(right instanceof Currency) || left.isSameType(right)) {
    return new left.constructor(value);
  }

  return new CurrencyRatio(value, left.constructor, right.constructor);
}

function bigNumberFnWrapper(method, isBoolean) {
  return function (other) {
    assertValidOperation(method, this, other);

    var otherBigNumber = other instanceof Currency ? other.toBigNumber() : other;

    var value = this.toBigNumber()[method](otherBigNumber);
    return isBoolean ? value : result(method, this, other, value);
  };
}

(0, _assign2.default)(Currency.prototype, mathFunctions.reduce(function (output, _ref) {
  var _ref2 = (0, _toArray3.default)(_ref),
      method = _ref2[0],
      aliases = _ref2.slice(1);

  output[method] = bigNumberFnWrapper(method);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(aliases), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var alias = _step.value;

      output[alias] = output[method];
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return output;
}, {}), booleanFunctions.reduce(function (output, _ref3) {
  var _ref4 = (0, _toArray3.default)(_ref3),
      method = _ref4[0],
      aliases = _ref4.slice(1);

  output[method] = bigNumberFnWrapper(method, true);
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (0, _getIterator3.default)(aliases), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var alias = _step2.value;

      output[alias] = output[method];
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return output;
}, {}));

var makeCreatorFnWithShift = function makeCreatorFnWithShift(creatorFn, symbol, shift) {
  var fn = function fn(amount) {
    return creatorFn(amount, shift);
  };
  // these two properties are used by getCurrency
  fn.symbol = symbol;
  fn.shift = shift;
  return fn;
};

function setupWrapper(symbol) {
  var CurrencyX = function (_Currency) {
    (0, _inherits3.default)(CurrencyX, _Currency);

    function CurrencyX(amount, shift) {
      (0, _classCallCheck3.default)(this, CurrencyX);

      var _this = (0, _possibleConstructorReturn3.default)(this, (CurrencyX.__proto__ || (0, _getPrototypeOf2.default)(CurrencyX)).call(this, amount, shift));

      _this.symbol = symbol;
      return _this;
    }

    return CurrencyX;
  }(Currency);

  // this changes the name of the class in stack traces


  Object.defineProperty(CurrencyX, 'name', { value: symbol });
  Object.defineProperty(CurrencyX, 'symbol', { value: symbol });

  // This provides short syntax, e.g. ETH(6). We need a wrapper function because
  // you can't call an ES6 class consructor without `new`
  var creatorFn = function creatorFn(amount, shift) {
    return new CurrencyX(amount, shift);
  };

  (0, _assign2.default)(creatorFn, {
    wei: makeCreatorFnWithShift(creatorFn, symbol, 'wei'),
    ray: makeCreatorFnWithShift(creatorFn, symbol, 'ray'),
    symbol: symbol,
    wrappedClass: CurrencyX
  });

  return creatorFn;
}

var currencies = exports.currencies = (0, _lodash2.default)(_tokens2.default).reduce(function (output, symbol) {
  output[symbol] = setupWrapper(symbol);
  return output;
}, {
  USD: setupWrapper('USD')
});

function getCurrency(amount, unit) {
  if (amount instanceof Currency) return amount;
  if (!unit) throw new Error('Unit not specified');
  var key = typeof unit === 'string' ? unit.toUpperCase() : unit.symbol;
  var ctor = currencies[key];
  if (!ctor) {
    throw new Error('Couldn\'t find currency for "' + key + '"');
  }
  return ctor(amount, unit.shift);
}

// FIXME: this is not exactly analogous to Currency above, because all the
// different pairs are instances of the same class rather than subclasses in
// their own right. but for now it works fine, because it's the wrapper
// functions that are used externally anyway. so if we want to be consistent, we
// could either create subclasses for each ratio, or refactor Currency so it
// also just stores its symbol in the instance rather than the subclass.

var CurrencyRatio = exports.CurrencyRatio = function (_Currency2) {
  (0, _inherits3.default)(CurrencyRatio, _Currency2);

  function CurrencyRatio(amount, numerator, denominator, shift) {
    (0, _classCallCheck3.default)(this, CurrencyRatio);

    var _this2 = (0, _possibleConstructorReturn3.default)(this, (CurrencyRatio.__proto__ || (0, _getPrototypeOf2.default)(CurrencyRatio)).call(this, amount, shift));

    _this2.numerator = numerator.wrappedClass || numerator;
    _this2.denominator = denominator.wrappedClass || denominator;
    _this2.symbol = numerator.symbol + '/' + denominator.symbol;
    return _this2;
  }

  return CurrencyRatio;
}(Currency);

var setupRatioWrapper = function setupRatioWrapper(numerator, denominator) {
  var creatorFn = function creatorFn(amount, shift) {
    return new CurrencyRatio(amount, numerator, denominator, shift);
  };

  var symbol = numerator.symbol + '/' + denominator.symbol;

  (0, _assign2.default)(creatorFn, {
    wei: makeCreatorFnWithShift(creatorFn, symbol, 'wei'),
    ray: makeCreatorFnWithShift(creatorFn, symbol, 'ray'),
    symbol: symbol
  });

  return creatorFn;
};

// we export both the currencies object and the individual currencies because
// the latter is convenient when you know what you want to use, and the former
// is convenient when you are picking a currency based on a symbol from input

var DAI = exports.DAI = currencies.DAI;
var ETH = exports.ETH = currencies.ETH;
var MKR = exports.MKR = currencies.MKR;
var PETH = exports.PETH = currencies.PETH;
var WETH = exports.WETH = currencies.WETH;
var USD = exports.USD = currencies.USD;

var USD_DAI = exports.USD_DAI = setupRatioWrapper(USD, DAI);
var USD_ETH = exports.USD_ETH = setupRatioWrapper(USD, ETH);
var USD_MKR = exports.USD_MKR = setupRatioWrapper(USD, MKR);
var USD_PETH = exports.USD_PETH = setupRatioWrapper(USD, PETH);
var USD_WETH = exports.USD_WETH = setupRatioWrapper(USD, WETH);

(0, _assign2.default)(currencies, {
  USD_DAI: USD_DAI,
  USD_ETH: USD_ETH,
  USD_MKR: USD_MKR,
  USD_PETH: USD_PETH,
  USD_WETH: USD_WETH
});